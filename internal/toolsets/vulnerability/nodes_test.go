package vulnerability

import (
	"context"
	"testing"

	"github.com/modelcontextprotocol/go-sdk/mcp"
	v1 "github.com/stackrox/rox/generated/api/v1"
	"github.com/stackrox/rox/generated/storage"
	"github.com/stackrox/stackrox-mcp/internal/client"
	"github.com/stackrox/stackrox-mcp/internal/toolsets/mock"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

func TestNewGetNodesForCVETool(t *testing.T) {
	tool := NewGetNodesForCVETool(&client.Client{})
	require.NotNil(t, tool)
	assert.Equal(t, "get_nodes_for_cve", tool.GetName())
}

func TestGetNodesForCVETool_IsReadOnly(t *testing.T) {
	c := &client.Client{}
	tool := NewGetNodesForCVETool(c)

	assert.True(t, tool.IsReadOnly(), "get_nodes_for_cve should be read-only")
}

func TestGetNodesForCVETool_GetTool(t *testing.T) {
	c := &client.Client{}
	tool := NewGetNodesForCVETool(c)

	mcpTool := tool.GetTool()

	require.NotNil(t, mcpTool)
	assert.Equal(t, "get_nodes_for_cve", mcpTool.Name)
	assert.Contains(t, mcpTool.Description, "aggregated")
	assert.NotNil(t, mcpTool.InputSchema)
}

func TestGetNodesForCVETool_RegisterWith(t *testing.T) {
	c := &client.Client{}
	tool := NewGetNodesForCVETool(c)
	server := mcp.NewServer(
		&mcp.Implementation{
			Name:    "test-server",
			Version: "1.0.0",
		},
		&mcp.ServerOptions{},
	)

	// Should not panic.
	assert.NotPanics(t, func() {
		tool.RegisterWith(server)
	})
}

// Unit tests for input validate method.
//
//nolint:dupl // Duplication to `TestClusterInputValidate` is detected. They use different input types.
func TestNodeInputValidate(t *testing.T) {
	tests := map[string]struct {
		input       getNodesForCVEInput
		expectError bool
		errorMsg    string
	}{
		"valid input with CVE only": {
			input:       getNodesForCVEInput{CVEName: "CVE-2021-44228"},
			expectError: false,
		},
		"missing CVE name (empty string)": {
			input:       getNodesForCVEInput{CVEName: ""},
			expectError: true,
			errorMsg:    "CVE name is required",
		},
		"missing CVE name (zero value)": {
			input:       getNodesForCVEInput{},
			expectError: true,
			errorMsg:    "CVE name is required",
		},
		"both cluster ID and name provided": {
			input: getNodesForCVEInput{
				CVEName:           "CVE-2021-44228",
				FilterClusterID:   "cluster-123",
				FilterClusterName: "production",
			},
			expectError: true,
			errorMsg:    "cannot specify both filterClusterId and filterClusterName",
		},
		"only cluster ID provided": {
			input: getNodesForCVEInput{
				CVEName:         "CVE-2021-44228",
				FilterClusterID: "cluster-123",
			},
			expectError: false,
		},
		"only cluster name provided": {
			input: getNodesForCVEInput{
				CVEName:           "CVE-2021-44228",
				FilterClusterName: "production",
			},
			expectError: false,
		},
	}

	for testName, testCase := range tests {
		t.Run(testName, func(t *testing.T) {
			err := testCase.input.validate()

			if !testCase.expectError {
				require.NoError(t, err)

				return
			}

			require.Error(t, err)
			assert.Contains(t, err.Error(), testCase.errorMsg)
		})
	}
}

// Integration tests for handle method.
func TestNodeHandle_MissingCVE(t *testing.T) {
	mockService := mock.NewNodeServiceMock(
		[]*storage.Node{},
		nil,
	)

	grpcServer, listener := mock.SetupNodeServer(mockService)
	defer grpcServer.Stop()

	testClient := createTestClient(t, listener)
	tool, ok := NewGetNodesForCVETool(testClient).(*getNodesForCVETool)
	require.True(t, ok)

	ctx := context.Background()
	req := &mcp.CallToolRequest{}
	inputWithoutCVEName := getNodesForCVEInput{}

	result, output, err := tool.handle(ctx, req, inputWithoutCVEName)

	require.Error(t, err)
	assert.Nil(t, result)
	assert.Nil(t, output)
	assert.Contains(t, err.Error(), "CVE name is required")
}

func TestNodeHandle_EmptyResults(t *testing.T) {
	mockService := mock.NewNodeServiceMock(
		[]*storage.Node{},
		nil,
	)

	grpcServer, listener := mock.SetupNodeServer(mockService)
	defer grpcServer.Stop()

	testClient := createTestClient(t, listener)
	tool, ok := NewGetNodesForCVETool(testClient).(*getNodesForCVETool)
	require.True(t, ok)

	ctx := context.Background()
	req := &mcp.CallToolRequest{}
	input := getNodesForCVEInput{
		CVEName: "CVE-9999-99999",
	}

	result, output, err := tool.handle(ctx, req, input)

	require.NoError(t, err)
	require.NotNil(t, output)
	assert.Nil(t, result)
	assert.Empty(t, output.NodeGroups, "Should have empty nodeGroups array")
}

func TestNodeHandle_ExportNodesError(t *testing.T) {
	mockService := mock.NewNodeServiceMock(
		[]*storage.Node{},
		status.Error(codes.Internal, "database error"),
	)

	grpcServer, listener := mock.SetupNodeServer(mockService)
	defer grpcServer.Stop()

	testClient := createTestClient(t, listener)
	tool, ok := NewGetNodesForCVETool(testClient).(*getNodesForCVETool)
	require.True(t, ok)

	ctx := context.Background()
	req := &mcp.CallToolRequest{}
	input := getNodesForCVEInput{
		CVEName: "CVE-2021-44228",
	}

	result, output, err := tool.handle(ctx, req, input)

	require.Error(t, err)
	assert.Nil(t, result)
	assert.Nil(t, output)
	assert.Contains(t, err.Error(), "database error")
}

func TestNodeHandle_Aggregation(t *testing.T) {
	mockService := mock.NewNodeServiceMock(
		[]*storage.Node{
			{Name: "n1", ClusterId: "c1", ClusterName: "Prod", OsImage: "Ubuntu 20.04"},
			{Name: "n2", ClusterId: "c1", ClusterName: "Prod", OsImage: "Ubuntu 20.04"},
			{Name: "n3", ClusterId: "c1", ClusterName: "Prod", OsImage: "Ubuntu 22.04"},
			{Name: "n4", ClusterId: "c2", ClusterName: "Dev", OsImage: "Ubuntu 20.04"},
			{Name: "n5", ClusterId: "c2", ClusterName: "Dev", OsImage: "Ubuntu 20.04"},
			{Name: "n6", ClusterId: "c1", ClusterName: "Prod", OsImage: "Ubuntu 20.04"},
		},
		nil,
	)

	grpcServer, listener := mock.SetupNodeServer(mockService)
	defer grpcServer.Stop()

	testClient := createTestClient(t, listener)
	tool, ok := NewGetNodesForCVETool(testClient).(*getNodesForCVETool)
	require.True(t, ok)

	ctx := context.Background()
	req := &mcp.CallToolRequest{}
	input := getNodesForCVEInput{
		CVEName: "CVE-2021-44228",
	}

	result, output, err := tool.handle(ctx, req, input)

	require.NoError(t, err)
	require.NotNil(t, output)
	assert.Nil(t, result)

	// Should have 3 groups:
	// - c1 + Ubuntu 20.04: count=2
	// - c1 + Ubuntu 22.04: count=1
	// - c2 + Ubuntu 20.04: count=1
	require.Len(t, output.NodeGroups, 3)

	// Verify first group (sorted by cluster, then OS).
	assert.Equal(t, "c1", output.NodeGroups[0].ClusterID)
	assert.Equal(t, "Prod", output.NodeGroups[0].ClusterName)
	assert.Equal(t, "Ubuntu 20.04", output.NodeGroups[0].OperatingSystem)
	assert.Equal(t, 3, output.NodeGroups[0].Count)

	// Verify second group (c1 + Ubuntu 22.04).
	assert.Equal(t, "c1", output.NodeGroups[1].ClusterID)
	assert.Equal(t, "Prod", output.NodeGroups[1].ClusterName)
	assert.Equal(t, "Ubuntu 22.04", output.NodeGroups[1].OperatingSystem)
	assert.Equal(t, 1, output.NodeGroups[1].Count)

	// Verify third group (c2 + Ubuntu 20.04).
	assert.Equal(t, "c2", output.NodeGroups[2].ClusterID)
	assert.Equal(t, "Dev", output.NodeGroups[2].ClusterName)
	assert.Equal(t, "Ubuntu 20.04", output.NodeGroups[2].OperatingSystem)
	assert.Equal(t, 2, output.NodeGroups[2].Count)
}

func TestNodeHandle_Sorting(t *testing.T) {
	mockService := mock.NewNodeServiceMock(
		[]*storage.Node{
			{Name: "n1", ClusterId: "z-cluster", ClusterName: "A", OsImage: "Ubuntu 20.04"},
			{Name: "n2", ClusterId: "a-cluster", ClusterName: "Z", OsImage: "RHEL 8"},
			{Name: "n3", ClusterId: "a-cluster", ClusterName: "Z", OsImage: "CentOS 7"},
			{Name: "n4", ClusterId: "z-cluster", ClusterName: "A", OsImage: ""},
		},
		nil,
	)

	grpcServer, listener := mock.SetupNodeServer(mockService)
	defer grpcServer.Stop()

	testClient := createTestClient(t, listener)
	tool, ok := NewGetNodesForCVETool(testClient).(*getNodesForCVETool)
	require.True(t, ok)

	ctx := context.Background()
	req := &mcp.CallToolRequest{}
	input := getNodesForCVEInput{
		CVEName: "CVE-2021-44228",
	}

	result, output, err := tool.handle(ctx, req, input)

	require.NoError(t, err)
	require.NotNil(t, output)
	assert.Nil(t, result)

	require.Len(t, output.NodeGroups, 4)

	// Should be sorted by cluster ID first, then OS.
	// Expected order:
	// 1. a-cluster + CentOS 7
	// 2. a-cluster + RHEL 8
	// 3. z-cluster + <empty os image>
	// 4. z-cluster + Ubuntu 20.04
	assert.Equal(t, "a-cluster", output.NodeGroups[0].ClusterID)
	assert.Equal(t, "CentOS 7", output.NodeGroups[0].OperatingSystem)

	assert.Equal(t, "a-cluster", output.NodeGroups[1].ClusterID)
	assert.Equal(t, "RHEL 8", output.NodeGroups[1].OperatingSystem)

	assert.Equal(t, "z-cluster", output.NodeGroups[2].ClusterID)
	assert.Empty(t, output.NodeGroups[2].OperatingSystem)

	assert.Equal(t, "z-cluster", output.NodeGroups[3].ClusterID)
	assert.Equal(t, "Ubuntu 20.04", output.NodeGroups[3].OperatingSystem)
}

func TestNodeHandle_WithFilters(t *testing.T) {
	mockService := mock.NewNodeServiceMock(
		[]*storage.Node{
			{Name: "n1", ClusterId: "cluster-1", ClusterName: "C1", OsImage: "Ubuntu 20.04"},
		},
		nil,
	)

	grpcServer, listener := mock.SetupNodeServer(mockService)
	defer grpcServer.Stop()

	tool, ok := NewGetNodesForCVETool(createTestClient(t, listener)).(*getNodesForCVETool)
	require.True(t, ok)

	tests := map[string]struct {
		input         getNodesForCVEInput
		expectedQuery string
	}{
		"CVE only": {
			input:         getNodesForCVEInput{CVEName: "CVE-2021-44228"},
			expectedQuery: `CVE:"CVE-2021-44228"`,
		},
		"CVE with cluster": {
			input: getNodesForCVEInput{
				CVEName:         "CVE-2021-44228",
				FilterClusterID: "cluster-123",
			},
			expectedQuery: `CVE:"CVE-2021-44228"+Cluster ID:"cluster-123"`,
		},
	}

	for testName, testCase := range tests {
		t.Run(testName, func(t *testing.T) {
			result, output, err := tool.handle(context.Background(), &mcp.CallToolRequest{}, testCase.input)

			require.NoError(t, err)
			require.NotNil(t, output)
			assert.Nil(t, result)
			assert.Len(t, output.NodeGroups, 1)
			assert.Equal(t, testCase.expectedQuery, mockService.GetLastCallQuery())
		})
	}
}

func TestNodeHandle_WithValidClusterNameFilter(t *testing.T) {
	tests := map[string]struct {
		clusterName      string
		returnedClusters []*storage.Cluster
		expectedQuery    string
	}{
		"cluster name found": {
			clusterName:      "production",
			returnedClusters: []*storage.Cluster{{Id: "cluster-1", Name: "production"}},
			expectedQuery:    `CVE:"CVE-2021-44228"+Cluster ID:"cluster-1"`,
		},
		"empty cluster name": {
			clusterName:      "",
			returnedClusters: []*storage.Cluster{},
			expectedQuery:    `CVE:"CVE-2021-44228"`,
		},
	}

	for testName, testCase := range tests {
		t.Run(testName, func(t *testing.T) {
			nodeService := mock.NewNodeServiceMock(
				[]*storage.Node{
					{Name: "n1", ClusterId: "cluster-1", ClusterName: "production", OsImage: "Ubuntu 20.04"},
				},
				nil,
			)
			clusterService := mock.NewClustersServiceMock(testCase.returnedClusters, nil)

			grpcServer, listener := mock.SetupAPIServer(
				v1.UnimplementedDeploymentServiceServer{},
				v1.UnimplementedImageServiceServer{},
				nodeService,
				clusterService,
			)
			defer grpcServer.Stop()

			tool, ok := NewGetNodesForCVETool(createTestClient(t, listener)).(*getNodesForCVETool)
			require.True(t, ok)

			input := getNodesForCVEInput{
				CVEName:           "CVE-2021-44228",
				FilterClusterName: testCase.clusterName,
			}

			result, output, err := tool.handle(context.Background(), &mcp.CallToolRequest{}, input)

			require.NoError(t, err)
			require.NotNil(t, output)
			assert.Nil(t, result)
			assert.Contains(t, nodeService.GetLastCallQuery(), testCase.expectedQuery)
		})
	}
}

func TestNodeHandle_WithNotValidClusterNameFilter(t *testing.T) {
	nodeService := mock.NewNodeServiceMock(
		[]*storage.Node{
			{Name: "n1", ClusterId: "cluster-1", ClusterName: "production", OsImage: "Ubuntu 20.04"},
		},
		nil,
	)
	clusterService := mock.NewClustersServiceMock([]*storage.Cluster{}, nil)

	grpcServer, listener := mock.SetupAPIServer(
		v1.UnimplementedDeploymentServiceServer{},
		v1.UnimplementedImageServiceServer{},
		nodeService,
		clusterService,
	)
	defer grpcServer.Stop()

	tool, ok := NewGetNodesForCVETool(createTestClient(t, listener)).(*getNodesForCVETool)
	require.True(t, ok)

	input := getNodesForCVEInput{
		CVEName:           "CVE-2021-44228",
		FilterClusterName: "nonexistent",
	}

	result, output, err := tool.handle(context.Background(), &mcp.CallToolRequest{}, input)

	require.Error(t, err)
	assert.Contains(t, err.Error(), `cluster with name "nonexistent" not found`)
	assert.Nil(t, result)
	assert.Nil(t, output)
}
