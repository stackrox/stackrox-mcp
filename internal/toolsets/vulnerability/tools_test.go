package vulnerability

import (
	"context"
	"fmt"
	"net"
	"testing"

	"github.com/modelcontextprotocol/go-sdk/mcp"
	v1 "github.com/stackrox/rox/generated/api/v1"
	"github.com/stackrox/rox/generated/storage"
	"github.com/stackrox/stackrox-mcp/internal/client"
	"github.com/stackrox/stackrox-mcp/internal/config"
	"github.com/stackrox/stackrox-mcp/internal/cursor"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/grpc/status"
	"google.golang.org/grpc/test/bufconn"
)

func TestNewGetDeploymentForCVETool(t *testing.T) {
	c := &client.Client{}
	tool := NewGetDeploymentsForCVETool(c)

	require.NotNil(t, tool)
	assert.Equal(t, "get_deployments_for_cve", tool.GetName())
}

func TestGetDeploymentForCVETool_IsReadOnly(t *testing.T) {
	c := &client.Client{}
	tool := NewGetDeploymentsForCVETool(c)

	assert.True(t, tool.IsReadOnly(), "get_deployments_for_cve should be read-only")
}

func TestGetDeploymentForCVETool_GetTool(t *testing.T) {
	c := &client.Client{}
	tool := NewGetDeploymentsForCVETool(c)

	mcpTool := tool.GetTool()

	require.NotNil(t, mcpTool)
	assert.Equal(t, "get_deployments_for_cve", mcpTool.Name)
	assert.NotEmpty(t, mcpTool.Description)
	assert.NotNil(t, mcpTool.InputSchema)
}

func TestGetDeploymentForCVETool_RegisterWith(t *testing.T) {
	c := &client.Client{}
	tool := NewGetDeploymentsForCVETool(c)
	server := mcp.NewServer(
		&mcp.Implementation{
			Name:    "test-server",
			Version: "1.0.0",
		},
		&mcp.ServerOptions{},
	)

	// Should not panic
	assert.NotPanics(t, func() {
		tool.RegisterWith(server)
	})
}

// Unit tests for input validate method.
func TestInputValidate(t *testing.T) {
	tests := map[string]struct {
		input       getDeploymentsForCVEInput
		expectError bool
		errorMsg    string
	}{
		"valid input with CVE only": {
			input:       getDeploymentsForCVEInput{CVEName: "CVE-2021-44228"},
			expectError: false,
		},
		"missing CVE name (empty string)": {
			input:       getDeploymentsForCVEInput{CVEName: ""},
			expectError: true,
			errorMsg:    "CVE name is required",
		},
		"missing CVE name (zero value)": {
			input:       getDeploymentsForCVEInput{},
			expectError: true,
			errorMsg:    "CVE name is required",
		},
	}

	for testName, testCase := range tests {
		t.Run(testName, func(t *testing.T) {
			err := testCase.input.validate()

			if testCase.expectError {
				require.Error(t, err)
				assert.Contains(t, err.Error(), testCase.errorMsg)
			} else {
				require.NoError(t, err)
			}
		})
	}
}

// Mock infrastructure for gRPC testing.

// mockDeploymentService implements v1.DeploymentServiceServer for testing.
type mockDeploymentService struct {
	v1.UnimplementedDeploymentServiceServer

	deployments []*storage.ListDeployment
	err         error

	lastCallQuery  string
	lastCallLimit  int32
	lastCallOffset int32
}

func (m *mockDeploymentService) ListDeployments(
	_ context.Context,
	query *v1.RawQuery,
) (*v1.ListDeploymentsResponse, error) {
	m.lastCallQuery = query.GetQuery()
	m.lastCallLimit = query.GetPagination().GetLimit()
	m.lastCallOffset = query.GetPagination().GetOffset()

	if m.err != nil {
		return nil, m.err
	}

	return &v1.ListDeploymentsResponse{
		Deployments: m.deployments,
	}, nil
}

// setupMockDeploymentServer creates an in-memory gRPC server using bufconn.
func setupMockDeploymentServer(mockService *mockDeploymentService) (*grpc.Server, *bufconn.Listener) {
	buffer := 1024 * 1024
	listener := bufconn.Listen(buffer)

	grpcServer := grpc.NewServer()
	v1.RegisterDeploymentServiceServer(grpcServer, mockService)

	go func() {
		_ = grpcServer.Serve(listener)
	}()

	return grpcServer, listener
}

// bufDialer creates a dialer function for bufconn.
func bufDialer(listener *bufconn.Listener) func(context.Context, string) (net.Conn, error) {
	return func(_ context.Context, _ string) (net.Conn, error) {
		return listener.Dial()
	}
}

// createTestClient creates a client connected to the mock server.
func createTestClient(t *testing.T, listener *bufconn.Listener) *client.Client {
	t.Helper()

	conn, err := grpc.NewClient(
		"passthrough://buffer",
		grpc.WithLocalDNSResolution(),
		grpc.WithContextDialer(bufDialer(listener)),
		grpc.WithTransportCredentials(insecure.NewCredentials()),
	)
	require.NoError(t, err)

	stackroxClient, err := client.NewClient(&config.CentralConfig{
		URL: "buffer",
	})
	require.NoError(t, err)

	// Inject mock connection for testing.
	stackroxClient.SetConnForTesting(t, conn)

	return stackroxClient
}

// Test helper functions.
func getTestDeployments(totalDeployments int) []*storage.ListDeployment {
	deployments := make([]*storage.ListDeployment, totalDeployments)

	for i := range totalDeployments {
		deployments[i] = &storage.ListDeployment{
			Name:      fmt.Sprintf("deployment-%d", i),
			Namespace: "default",
			ClusterId: "cluster-1",
			Cluster:   "Production",
		}
	}

	return deployments
}

// Integration tests for handle method.
func TestHandle_MissingCVE(t *testing.T) {
	mockService := &mockDeploymentService{
		deployments: []*storage.ListDeployment{},
	}

	grpcServer, listener := setupMockDeploymentServer(mockService)
	defer grpcServer.Stop()

	testClient := createTestClient(t, listener)
	tool, ok := NewGetDeploymentsForCVETool(testClient).(*getDeploymentsForCVETool)
	require.True(t, ok)

	ctx := context.Background()
	req := &mcp.CallToolRequest{}
	inputWithoutCVEName := getDeploymentsForCVEInput{}

	result, output, err := tool.handle(ctx, req, inputWithoutCVEName)

	require.Error(t, err)
	assert.Nil(t, result)
	assert.Nil(t, output)
	assert.Contains(t, err.Error(), "CVE name is required")
}

func TestHandle_WithPagination(t *testing.T) {
	mockService := &mockDeploymentService{
		deployments: getTestDeployments(defaultLimit + 1),
	}

	grpcServer, listener := setupMockDeploymentServer(mockService)
	defer grpcServer.Stop()

	testClient := createTestClient(t, listener)
	tool, ok := NewGetDeploymentsForCVETool(testClient).(*getDeploymentsForCVETool)
	require.True(t, ok)

	currCursor, err := cursor.New(2)
	require.NoError(t, err)

	currCursorStr, err := currCursor.Encode()
	require.NoError(t, err)

	ctx := context.Background()
	req := &mcp.CallToolRequest{}
	input := getDeploymentsForCVEInput{
		CVEName: "CVE-2021-44228",
		Cursor:  currCursorStr,
	}

	result, output, err := tool.handle(ctx, req, input)

	require.NoError(t, err)
	require.NotNil(t, output)
	assert.Nil(t, result)

	assert.Len(t, output.Deployments, defaultLimit)
	assert.Equal(t, int32(2), mockService.lastCallOffset)
	assert.Equal(t, int32(defaultLimit+1), mockService.lastCallLimit)

	nextCursor := currCursor.GetNextCursor(defaultLimit)
	returnedCursor, err := cursor.Decode(output.NextCursor)
	require.NoError(t, err)
	assert.Equal(t, nextCursor.GetOffset(), returnedCursor.GetOffset())
}

func TestHandle_EmptyResults(t *testing.T) {
	mockService := &mockDeploymentService{
		deployments: []*storage.ListDeployment{},
	}

	grpcServer, listener := setupMockDeploymentServer(mockService)
	defer grpcServer.Stop()

	testClient := createTestClient(t, listener)
	tool, ok := NewGetDeploymentsForCVETool(testClient).(*getDeploymentsForCVETool)
	require.True(t, ok)

	ctx := context.Background()
	req := &mcp.CallToolRequest{}
	input := getDeploymentsForCVEInput{
		CVEName: "CVE-9999-99999",
	}

	result, output, err := tool.handle(ctx, req, input)

	require.NoError(t, err)
	require.NotNil(t, output)
	assert.Nil(t, result)
	assert.Empty(t, output.Deployments)
}

func TestHandle_ListDeploymentsError(t *testing.T) {
	mockService := &mockDeploymentService{
		err: status.Error(codes.Internal, "database error"),
	}

	grpcServer, listener := setupMockDeploymentServer(mockService)
	defer grpcServer.Stop()

	testClient := createTestClient(t, listener)
	tool, ok := NewGetDeploymentsForCVETool(testClient).(*getDeploymentsForCVETool)
	require.True(t, ok)

	ctx := context.Background()
	req := &mcp.CallToolRequest{}
	input := getDeploymentsForCVEInput{
		CVEName: "CVE-2021-44228",
	}

	result, output, err := tool.handle(ctx, req, input)

	require.Error(t, err)
	assert.Nil(t, result)
	assert.Nil(t, output)
	assert.Contains(t, err.Error(), "Internal server error")
}

func TestHandle_WithFilters(t *testing.T) {
	mockService := &mockDeploymentService{deployments: getTestDeployments(1)}

	grpcServer, listener := setupMockDeploymentServer(mockService)
	defer grpcServer.Stop()

	tool, ok := NewGetDeploymentsForCVETool(createTestClient(t, listener)).(*getDeploymentsForCVETool)
	require.True(t, ok)

	tests := map[string]struct {
		input         getDeploymentsForCVEInput
		expectedQuery string
	}{
		"CVE only": {
			input:         getDeploymentsForCVEInput{CVEName: "CVE-2021-44228"},
			expectedQuery: `CVE:"CVE-2021-44228"`,
		},
		"CVE with cluster": {
			input: getDeploymentsForCVEInput{
				CVEName:         "CVE-2021-44228",
				FilterClusterID: "cluster-123",
			},
			expectedQuery: `CVE:"CVE-2021-44228"+Cluster ID:"cluster-123"`,
		},
		"CVE with namespace": {
			input: getDeploymentsForCVEInput{
				CVEName:         "CVE-2021-44228",
				FilterNamespace: "kube-system",
				FilterPlatform:  filterPlatformNoFilter,
			},
			expectedQuery: `CVE:"CVE-2021-44228"+Namespace:"kube-system"`,
		},
		"CVE with platform filter 1 (platform)": {
			input: getDeploymentsForCVEInput{
				CVEName:        "CVE-2021-44228",
				FilterPlatform: filterPlatformPlatform,
			},
			expectedQuery: `CVE:"CVE-2021-44228"+Platform Component:1`,
		},
		"CVE with all filters": {
			input: getDeploymentsForCVEInput{
				CVEName:         "CVE-2021-44228",
				FilterClusterID: "cluster-123",
				FilterNamespace: "default",
				FilterPlatform:  filterPlatformUserWorkload,
			},
			expectedQuery: `CVE:"CVE-2021-44228"+Cluster ID:"cluster-123"+Namespace:"default"+Platform Component:0`,
		},
	}

	for testName, testCase := range tests {
		t.Run(testName, func(t *testing.T) {
			result, output, err := tool.handle(context.Background(), &mcp.CallToolRequest{}, testCase.input)

			require.NoError(t, err)
			require.NotNil(t, output)
			assert.Nil(t, result)
			assert.Len(t, output.Deployments, 1)
			assert.Equal(t, testCase.expectedQuery, mockService.lastCallQuery)
		})
	}
}
