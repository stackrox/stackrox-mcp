package vulnerability

import (
	"context"
	"errors"
	"net"
	"testing"

	"github.com/stackrox/rox/generated/storage"
	"github.com/stackrox/stackrox-mcp/internal/toolsets/mock"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/grpc/test/bufconn"
)

func getBufferConnection(t *testing.T, listener *bufconn.Listener) *grpc.ClientConn {
	t.Helper()

	// Create a gRPC client connection to the mock server
	conn, err := grpc.NewClient(
		"passthrough://buffer",
		grpc.WithLocalDNSResolution(),
		grpc.WithContextDialer(func(_ context.Context, _ string) (net.Conn, error) {
			return listener.Dial()
		}),
		grpc.WithTransportCredentials(insecure.NewCredentials()),
	)
	require.NoError(t, err)

	return conn
}

func TestResolveClusterID_Success(t *testing.T) {
	tests := map[string]struct {
		clusterID     string
		clusterName   string
		mockClusters  []*storage.Cluster
		mockError     error
		expectedID    string
		expectedQuery string
	}{
		"only cluster ID": {
			clusterID:    "only-cluster-id",
			clusterName:  "",
			mockClusters: []*storage.Cluster{{Id: "cluster-1", Name: "production"}},
			expectedID:   "only-cluster-id",
		},
		"cluster ID has priority": {
			clusterID:    "cluster-with-priority",
			clusterName:  "production",
			mockClusters: []*storage.Cluster{{Id: "cluster-1", Name: "production"}},
			expectedID:   "cluster-with-priority",
		},
		"empty cluster name returns empty ID": {
			clusterID:    "",
			clusterName:  "",
			mockClusters: []*storage.Cluster{{Id: "cluster-1", Name: "production"}},
			expectedID:   "",
		},
		"cluster name found returns correct ID": {
			clusterID:     "",
			clusterName:   "production",
			mockClusters:  []*storage.Cluster{{Id: "cluster-1", Name: "production"}},
			expectedID:    "cluster-1",
			expectedQuery: `Cluster:"production"`,
		},
	}

	for testName, testCase := range tests {
		t.Run(testName, func(t *testing.T) {
			mockService := mock.NewClustersServiceMock(testCase.mockClusters, testCase.mockError)

			grpcServer, listener := mock.SetupClusterServer(mockService)
			defer grpcServer.Stop()

			conn := getBufferConnection(t, listener)

			defer func() { _ = conn.Close() }()

			clusterID, err := resolveClusterID(
				context.Background(),
				conn,
				testCase.clusterID,
				testCase.clusterName,
			)

			require.NoError(t, err)
			assert.Equal(t, testCase.expectedID, clusterID)
			assert.Equal(t, testCase.expectedQuery, mockService.GetLastCallQuery())
		})
	}
}

func TestResolveClusterID_Failure(t *testing.T) {
	tests := map[string]struct {
		clusterName     string
		mockClusters    []*storage.Cluster
		mockError       error
		expectedErrText string
		expectedQuery   string
	}{
		"cluster name not found returns error": {
			clusterName:     "nonexistent",
			mockClusters:    []*storage.Cluster{},
			expectedErrText: `cluster with name "nonexistent" not found`,
			expectedQuery:   `Cluster:"nonexistent"`,
		},
		"API error propagation": {
			clusterName:     "production",
			mockError:       errors.New("API connection failed"),
			expectedErrText: "failed to fetch clusters:",
			expectedQuery:   `Cluster:"production"`,
		},
	}

	for testName, testCase := range tests {
		t.Run(testName, func(t *testing.T) {
			mockService := mock.NewClustersServiceMock(testCase.mockClusters, testCase.mockError)

			grpcServer, listener := mock.SetupClusterServer(mockService)
			defer grpcServer.Stop()

			conn := getBufferConnection(t, listener)

			defer func() { _ = conn.Close() }()

			clusterID, err := resolveClusterID(
				context.Background(),
				conn,
				"",
				testCase.clusterName,
			)

			require.Error(t, err)
			assert.Empty(t, clusterID)
			assert.Contains(t, err.Error(), testCase.expectedErrText)

			assert.Equal(t, testCase.expectedQuery, mockService.GetLastCallQuery())
		})
	}
}
