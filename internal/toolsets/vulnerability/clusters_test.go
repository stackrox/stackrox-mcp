package vulnerability

import (
	"context"
	"testing"

	"github.com/modelcontextprotocol/go-sdk/mcp"
	"github.com/stackrox/rox/generated/storage"
	"github.com/stackrox/stackrox-mcp/internal/client"
	"github.com/stackrox/stackrox-mcp/internal/toolsets/mock"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

func TestNewGetClustersForCVETool(t *testing.T) {
	tool := NewGetClustersForCVETool(&client.Client{})
	require.NotNil(t, tool)
	assert.Equal(t, "get_clusters_with_orchestrator_cve", tool.GetName())
}

func TestGetClustersForCVETool_IsReadOnly(t *testing.T) {
	c := &client.Client{}
	tool := NewGetClustersForCVETool(c)

	assert.True(t, tool.IsReadOnly(), "get_clusters_with_orchestrator_cve should be read-only")
}

func TestGetClustersForCVETool_GetTool(t *testing.T) {
	c := &client.Client{}
	tool := NewGetClustersForCVETool(c)

	mcpTool := tool.GetTool()

	require.NotNil(t, mcpTool)
	assert.Equal(t, "get_clusters_with_orchestrator_cve", mcpTool.Name)
	assert.Contains(t, mcpTool.Description, "clusters where")
	assert.Contains(t, mcpTool.Description, "CVE is detected")
	assert.NotNil(t, mcpTool.InputSchema)
}

func TestGetClustersForCVETool_RegisterWith(t *testing.T) {
	c := &client.Client{}
	tool := NewGetClustersForCVETool(c)
	server := mcp.NewServer(
		&mcp.Implementation{
			Name:    "test-server",
			Version: "1.0.0",
		},
		&mcp.ServerOptions{},
	)

	// Should not panic.
	assert.NotPanics(t, func() {
		tool.RegisterWith(server)
	})
}

// Unit tests for input validate method.
//
//nolint:dupl // Duplication to `TestNodeInputValidate` is detected. They use different input types.
func TestClusterInputValidate(t *testing.T) {
	tests := map[string]struct {
		input       getClustersForCVEInput
		expectError bool
		errorMsg    string
	}{
		"valid input with CVE only": {
			input:       getClustersForCVEInput{CVEName: "CVE-2021-44228"},
			expectError: false,
		},
		"missing CVE name (empty string)": {
			input:       getClustersForCVEInput{CVEName: ""},
			expectError: true,
			errorMsg:    "CVE name is required",
		},
		"missing CVE name (zero value)": {
			input:       getClustersForCVEInput{},
			expectError: true,
			errorMsg:    "CVE name is required",
		},
		"both cluster ID and name provided": {
			input: getClustersForCVEInput{
				CVEName:           "CVE-2021-44228",
				FilterClusterID:   "cluster-123",
				FilterClusterName: "production",
			},
			expectError: true,
			errorMsg:    "cannot specify both filterClusterId and filterClusterName",
		},
		"only cluster ID provided": {
			input: getClustersForCVEInput{
				CVEName:         "CVE-2021-44228",
				FilterClusterID: "cluster-123",
			},
			expectError: false,
		},
		"only cluster name provided": {
			input: getClustersForCVEInput{
				CVEName:           "CVE-2021-44228",
				FilterClusterName: "production",
			},
			expectError: false,
		},
	}

	for testName, testCase := range tests {
		t.Run(testName, func(t *testing.T) {
			err := testCase.input.validate()

			if !testCase.expectError {
				require.NoError(t, err)

				return
			}

			require.Error(t, err)
			assert.Contains(t, err.Error(), testCase.errorMsg)
		})
	}
}

// Integration tests for handle method.
func TestClusterHandle_MissingCVE(t *testing.T) {
	mockService := mock.NewClustersServiceMock([]*storage.Cluster{}, nil)

	grpcServer, listener := mock.SetupClusterServer(mockService)
	defer grpcServer.Stop()

	testClient := createTestClient(t, listener)
	tool, ok := NewGetClustersForCVETool(testClient).(*getClustersForCVETool)
	require.True(t, ok)

	ctx := context.Background()
	req := &mcp.CallToolRequest{}
	inputWithoutCVEName := getClustersForCVEInput{}

	result, output, err := tool.handle(ctx, req, inputWithoutCVEName)

	require.Error(t, err)
	assert.Nil(t, result)
	assert.Nil(t, output)
	assert.Contains(t, err.Error(), "CVE name is required")
}

func TestClusterHandle_EmptyResults(t *testing.T) {
	mockService := mock.NewClustersServiceMock([]*storage.Cluster{}, nil)

	grpcServer, listener := mock.SetupClusterServer(mockService)
	defer grpcServer.Stop()

	testClient := createTestClient(t, listener)
	tool, ok := NewGetClustersForCVETool(testClient).(*getClustersForCVETool)
	require.True(t, ok)

	ctx := context.Background()
	req := &mcp.CallToolRequest{}
	input := getClustersForCVEInput{
		CVEName: "CVE-9999-99999",
	}

	result, output, err := tool.handle(ctx, req, input)

	require.NoError(t, err)
	require.NotNil(t, output)
	assert.Nil(t, result)
	assert.Empty(t, output.Clusters, "Should have empty clusters array")
}

func TestClusterHandle_GetClustersError(t *testing.T) {
	mockService := mock.NewClustersServiceMock([]*storage.Cluster{}, status.Error(codes.Internal, "database error"))

	grpcServer, listener := mock.SetupClusterServer(mockService)
	defer grpcServer.Stop()

	testClient := createTestClient(t, listener)
	tool, ok := NewGetClustersForCVETool(testClient).(*getClustersForCVETool)
	require.True(t, ok)

	ctx := context.Background()
	req := &mcp.CallToolRequest{}
	input := getClustersForCVEInput{
		CVEName: "CVE-2021-44228",
	}

	result, output, err := tool.handle(ctx, req, input)

	require.Error(t, err)
	assert.Nil(t, result)
	assert.Nil(t, output)
	assert.Contains(t, err.Error(), "database error")
}

func TestClusterHandle_MultipleResults(t *testing.T) {
	mockService := mock.NewClustersServiceMock(
		[]*storage.Cluster{
			{Id: "cluster-z", Name: "Production"},
			{Id: "cluster-a", Name: "Development"},
			{Id: "cluster-m", Name: "Testing"},
		},
		nil,
	)

	grpcServer, listener := mock.SetupClusterServer(mockService)
	defer grpcServer.Stop()

	testClient := createTestClient(t, listener)
	tool, ok := NewGetClustersForCVETool(testClient).(*getClustersForCVETool)
	require.True(t, ok)

	ctx := context.Background()
	req := &mcp.CallToolRequest{}
	input := getClustersForCVEInput{
		CVEName: "CVE-2021-44228",
	}

	result, output, err := tool.handle(ctx, req, input)

	require.NoError(t, err)
	require.NotNil(t, output)
	assert.Nil(t, result)

	// Should have 3 clusters, sorted by ID.
	require.Len(t, output.Clusters, 3)
	assert.Equal(t, "cluster-a", output.Clusters[0].ClusterID)
	assert.Equal(t, "Development", output.Clusters[0].ClusterName)

	assert.Equal(t, "cluster-m", output.Clusters[1].ClusterID)
	assert.Equal(t, "Testing", output.Clusters[1].ClusterName)

	assert.Equal(t, "cluster-z", output.Clusters[2].ClusterID)
	assert.Equal(t, "Production", output.Clusters[2].ClusterName)

	// Verify query was built correctly.
	assert.Equal(t, `CVE:"CVE-2021-44228"`, mockService.GetLastCallQuery())
}

func TestClusterHandle_Sorting(t *testing.T) {
	mockService := mock.NewClustersServiceMock(
		[]*storage.Cluster{
			{Id: "z-cluster", Name: "A"},
			{Id: "a-cluster", Name: "Z"},
			{Id: "m-cluster", Name: "M"},
		},
		nil,
	)

	grpcServer, listener := mock.SetupClusterServer(mockService)
	defer grpcServer.Stop()

	testClient := createTestClient(t, listener)
	tool, ok := NewGetClustersForCVETool(testClient).(*getClustersForCVETool)
	require.True(t, ok)

	ctx := context.Background()
	req := &mcp.CallToolRequest{}
	input := getClustersForCVEInput{
		CVEName: "CVE-2021-44228",
	}

	result, output, err := tool.handle(ctx, req, input)

	require.NoError(t, err)
	require.NotNil(t, output)
	assert.Nil(t, result)

	require.Len(t, output.Clusters, 3)

	// Should be sorted by cluster ID alphabetically.
	// Expected order: a-cluster, m-cluster, z-cluster
	assert.Equal(t, "a-cluster", output.Clusters[0].ClusterID)
	assert.Equal(t, "Z", output.Clusters[0].ClusterName)

	assert.Equal(t, "m-cluster", output.Clusters[1].ClusterID)
	assert.Equal(t, "M", output.Clusters[1].ClusterName)

	assert.Equal(t, "z-cluster", output.Clusters[2].ClusterID)
	assert.Equal(t, "A", output.Clusters[2].ClusterName)
}

func TestClusterHandle_WithFilters(t *testing.T) {
	mockService := mock.NewClustersServiceMock(
		[]*storage.Cluster{
			{Id: "cluster-1", Name: "C1"},
		},
		nil,
	)

	grpcServer, listener := mock.SetupClusterServer(mockService)
	defer grpcServer.Stop()

	tool, ok := NewGetClustersForCVETool(createTestClient(t, listener)).(*getClustersForCVETool)
	require.True(t, ok)

	tests := map[string]struct {
		input         getClustersForCVEInput
		expectedQuery string
	}{
		"CVE only": {
			input:         getClustersForCVEInput{CVEName: "CVE-2021-44228"},
			expectedQuery: `CVE:"CVE-2021-44228"`,
		},
		"CVE with cluster": {
			input: getClustersForCVEInput{
				CVEName:         "CVE-2021-44228",
				FilterClusterID: "cluster-123",
			},
			expectedQuery: `CVE:"CVE-2021-44228"+Cluster ID:"cluster-123"`,
		},
	}

	for testName, testCase := range tests {
		t.Run(testName, func(t *testing.T) {
			result, output, err := tool.handle(context.Background(), &mcp.CallToolRequest{}, testCase.input)

			require.NoError(t, err)
			require.NotNil(t, output)
			assert.Nil(t, result)
			assert.Len(t, output.Clusters, 1)
			assert.Equal(t, testCase.expectedQuery, mockService.GetLastCallQuery())
		})
	}
}

func TestClusterHandle_WithValidClusterNameFilter(t *testing.T) {
	tests := map[string]struct {
		clusterName      string
		returnedClusters []*storage.Cluster
		expectedQuery    string
	}{
		"cluster name found": {
			clusterName:      "production",
			returnedClusters: []*storage.Cluster{{Id: "cluster-1", Name: "production"}},
			expectedQuery:    `CVE:"CVE-2021-44228"+Cluster ID:"cluster-1"`,
		},
		"empty cluster name": {
			clusterName:      "",
			returnedClusters: []*storage.Cluster{},
			expectedQuery:    `CVE:"CVE-2021-44228"`,
		},
	}

	for testName, testCase := range tests {
		t.Run(testName, func(t *testing.T) {
			mockService := mock.NewClustersServiceMock(testCase.returnedClusters, nil)

			grpcServer, listener := mock.SetupClusterServer(mockService)
			defer grpcServer.Stop()

			tool, ok := NewGetClustersForCVETool(createTestClient(t, listener)).(*getClustersForCVETool)
			require.True(t, ok)

			input := getClustersForCVEInput{
				CVEName:           "CVE-2021-44228",
				FilterClusterName: testCase.clusterName,
			}

			result, output, err := tool.handle(context.Background(), &mcp.CallToolRequest{}, input)

			require.NoError(t, err)
			require.NotNil(t, output)
			assert.Nil(t, result)
			assert.Contains(t, mockService.GetLastCallQuery(), testCase.expectedQuery)
		})
	}
}

func TestClusterHandle_WithNotValidClusterNameFilter(t *testing.T) {
	mockService := mock.NewClustersServiceMock([]*storage.Cluster{}, nil)

	grpcServer, listener := mock.SetupClusterServer(mockService)
	defer grpcServer.Stop()

	tool, ok := NewGetClustersForCVETool(createTestClient(t, listener)).(*getClustersForCVETool)
	require.True(t, ok)

	input := getClustersForCVEInput{
		CVEName:           "CVE-2021-44228",
		FilterClusterName: "nonexistent",
	}

	result, output, err := tool.handle(context.Background(), &mcp.CallToolRequest{}, input)

	require.Error(t, err)
	assert.Contains(t, err.Error(), `cluster with name "nonexistent" not found`)
	assert.Nil(t, result)
	assert.Nil(t, output)
}
