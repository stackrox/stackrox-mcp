package vulnerability

import (
	"context"
	"testing"

	"github.com/modelcontextprotocol/go-sdk/mcp"
	v1 "github.com/stackrox/rox/generated/api/v1"
	"github.com/stackrox/rox/generated/storage"
	"github.com/stackrox/stackrox-mcp/internal/client"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

func TestNewGetClustersForCVETool(t *testing.T) {
	tool := NewGetClustersForCVETool(&client.Client{})
	require.NotNil(t, tool)
	assert.Equal(t, "get_clusters_for_cve", tool.GetName())
}

func TestGetClustersForCVETool_IsReadOnly(t *testing.T) {
	c := &client.Client{}
	tool := NewGetClustersForCVETool(c)

	assert.True(t, tool.IsReadOnly(), "get_clusters_for_cve should be read-only")
}

func TestGetClustersForCVETool_GetTool(t *testing.T) {
	c := &client.Client{}
	tool := NewGetClustersForCVETool(c)

	mcpTool := tool.GetTool()

	require.NotNil(t, mcpTool)
	assert.Equal(t, "get_clusters_for_cve", mcpTool.Name)
	assert.Contains(t, mcpTool.Description, "clusters affected")
	assert.NotNil(t, mcpTool.InputSchema)
}

func TestGetClustersForCVETool_RegisterWith(t *testing.T) {
	c := &client.Client{}
	tool := NewGetClustersForCVETool(c)
	server := mcp.NewServer(
		&mcp.Implementation{
			Name:    "test-server",
			Version: "1.0.0",
		},
		&mcp.ServerOptions{},
	)

	// Should not panic.
	assert.NotPanics(t, func() {
		tool.RegisterWith(server)
	})
}

// Unit tests for input validate method.
func TestClusterInputValidate(t *testing.T) {
	tests := map[string]struct {
		input       getClustersForCVEInput
		expectError bool
		errorMsg    string
	}{
		"valid input with CVE only": {
			input:       getClustersForCVEInput{CVEName: "CVE-2021-44228"},
			expectError: false,
		},
		"missing CVE name (empty string)": {
			input:       getClustersForCVEInput{CVEName: ""},
			expectError: true,
			errorMsg:    "CVE name is required",
		},
		"missing CVE name (zero value)": {
			input:       getClustersForCVEInput{},
			expectError: true,
			errorMsg:    "CVE name is required",
		},
	}

	for testName, testCase := range tests {
		t.Run(testName, func(t *testing.T) {
			err := testCase.input.validate()

			if !testCase.expectError {
				require.NoError(t, err)

				return
			}

			require.Error(t, err)
			assert.Contains(t, err.Error(), testCase.errorMsg)
		})
	}
}

// Mock infrastructure for gRPC testing.

// mockClustersService implements v1.ClustersServiceServer for testing.
type mockClustersService struct {
	v1.UnimplementedClustersServiceServer

	clusters      []*storage.Cluster
	err           error
	lastCallQuery string
}

func (m *mockClustersService) GetClusters(
	_ context.Context,
	req *v1.GetClustersRequest,
) (*v1.ClustersList, error) {
	m.lastCallQuery = req.GetQuery()

	if m.err != nil {
		return nil, m.err
	}

	return &v1.ClustersList{
		Clusters: m.clusters,
	}, nil
}

// Integration tests for handle method.
func TestClusterHandle_MissingCVE(t *testing.T) {
	mockService := &mockClustersService{
		clusters: []*storage.Cluster{},
	}

	grpcServer, listener := setupMockDeploymentServer(&mockDeploymentService{})
	defer grpcServer.Stop()

	v1.RegisterClustersServiceServer(grpcServer, mockService)

	testClient := createTestClient(t, listener)
	tool, ok := NewGetClustersForCVETool(testClient).(*getClustersForCVETool)
	require.True(t, ok)

	ctx := context.Background()
	req := &mcp.CallToolRequest{}
	inputWithoutCVEName := getClustersForCVEInput{}

	result, output, err := tool.handle(ctx, req, inputWithoutCVEName)

	require.Error(t, err)
	assert.Nil(t, result)
	assert.Nil(t, output)
	assert.Contains(t, err.Error(), "CVE name is required")
}

func TestClusterHandle_EmptyResults(t *testing.T) {
	mockService := &mockClustersService{
		clusters: []*storage.Cluster{},
	}

	grpcServer, listener := setupMockDeploymentServer(&mockDeploymentService{})
	defer grpcServer.Stop()

	v1.RegisterClustersServiceServer(grpcServer, mockService)

	testClient := createTestClient(t, listener)
	tool, ok := NewGetClustersForCVETool(testClient).(*getClustersForCVETool)
	require.True(t, ok)

	ctx := context.Background()
	req := &mcp.CallToolRequest{}
	input := getClustersForCVEInput{
		CVEName: "CVE-9999-99999",
	}

	result, output, err := tool.handle(ctx, req, input)

	require.NoError(t, err)
	require.NotNil(t, output)
	assert.Nil(t, result)
	assert.Empty(t, output.Clusters, "Should have empty clusters array")
}

func TestClusterHandle_GetClustersError(t *testing.T) {
	mockService := &mockClustersService{
		err: status.Error(codes.Internal, "database error"),
	}

	grpcServer, listener := setupMockDeploymentServer(&mockDeploymentService{})
	defer grpcServer.Stop()

	v1.RegisterClustersServiceServer(grpcServer, mockService)

	testClient := createTestClient(t, listener)
	tool, ok := NewGetClustersForCVETool(testClient).(*getClustersForCVETool)
	require.True(t, ok)

	ctx := context.Background()
	req := &mcp.CallToolRequest{}
	input := getClustersForCVEInput{
		CVEName: "CVE-2021-44228",
	}

	result, output, err := tool.handle(ctx, req, input)

	require.Error(t, err)
	assert.Nil(t, result)
	assert.Nil(t, output)
	assert.Contains(t, err.Error(), "database error")
}

func TestClusterHandle_MultipleResults(t *testing.T) {
	mockService := &mockClustersService{
		clusters: []*storage.Cluster{
			{Id: "cluster-z", Name: "Production"},
			{Id: "cluster-a", Name: "Development"},
			{Id: "cluster-m", Name: "Testing"},
		},
	}

	grpcServer, listener := setupMockDeploymentServer(&mockDeploymentService{})
	defer grpcServer.Stop()

	v1.RegisterClustersServiceServer(grpcServer, mockService)

	testClient := createTestClient(t, listener)
	tool, ok := NewGetClustersForCVETool(testClient).(*getClustersForCVETool)
	require.True(t, ok)

	ctx := context.Background()
	req := &mcp.CallToolRequest{}
	input := getClustersForCVEInput{
		CVEName: "CVE-2021-44228",
	}

	result, output, err := tool.handle(ctx, req, input)

	require.NoError(t, err)
	require.NotNil(t, output)
	assert.Nil(t, result)

	// Should have 3 clusters, sorted by ID.
	require.Len(t, output.Clusters, 3)
	assert.Equal(t, "cluster-a", output.Clusters[0].ClusterID)
	assert.Equal(t, "Development", output.Clusters[0].ClusterName)

	assert.Equal(t, "cluster-m", output.Clusters[1].ClusterID)
	assert.Equal(t, "Testing", output.Clusters[1].ClusterName)

	assert.Equal(t, "cluster-z", output.Clusters[2].ClusterID)
	assert.Equal(t, "Production", output.Clusters[2].ClusterName)

	// Verify query was built correctly.
	assert.Equal(t, `CVE:"CVE-2021-44228"`, mockService.lastCallQuery)
}

func TestClusterHandle_Sorting(t *testing.T) {
	mockService := &mockClustersService{
		clusters: []*storage.Cluster{
			{Id: "z-cluster", Name: "A"},
			{Id: "a-cluster", Name: "Z"},
			{Id: "m-cluster", Name: "M"},
		},
	}

	grpcServer, listener := setupMockDeploymentServer(&mockDeploymentService{})
	defer grpcServer.Stop()

	v1.RegisterClustersServiceServer(grpcServer, mockService)

	testClient := createTestClient(t, listener)
	tool, ok := NewGetClustersForCVETool(testClient).(*getClustersForCVETool)
	require.True(t, ok)

	ctx := context.Background()
	req := &mcp.CallToolRequest{}
	input := getClustersForCVEInput{
		CVEName: "CVE-2021-44228",
	}

	result, output, err := tool.handle(ctx, req, input)

	require.NoError(t, err)
	require.NotNil(t, output)
	assert.Nil(t, result)

	require.Len(t, output.Clusters, 3)

	// Should be sorted by cluster ID alphabetically.
	// Expected order: a-cluster, m-cluster, z-cluster
	assert.Equal(t, "a-cluster", output.Clusters[0].ClusterID)
	assert.Equal(t, "Z", output.Clusters[0].ClusterName)

	assert.Equal(t, "m-cluster", output.Clusters[1].ClusterID)
	assert.Equal(t, "M", output.Clusters[1].ClusterName)

	assert.Equal(t, "z-cluster", output.Clusters[2].ClusterID)
	assert.Equal(t, "A", output.Clusters[2].ClusterName)
}

func TestClusterHandle_WithFilters(t *testing.T) {
	mockService := &mockClustersService{
		clusters: []*storage.Cluster{
			{Id: "cluster-1", Name: "C1"},
		},
	}

	grpcServer, listener := setupMockDeploymentServer(&mockDeploymentService{})
	defer grpcServer.Stop()

	v1.RegisterClustersServiceServer(grpcServer, mockService)

	tool, ok := NewGetClustersForCVETool(createTestClient(t, listener)).(*getClustersForCVETool)
	require.True(t, ok)

	tests := map[string]struct {
		input         getClustersForCVEInput
		expectedQuery string
	}{
		"CVE only": {
			input:         getClustersForCVEInput{CVEName: "CVE-2021-44228"},
			expectedQuery: `CVE:"CVE-2021-44228"`,
		},
		"CVE with cluster": {
			input: getClustersForCVEInput{
				CVEName:         "CVE-2021-44228",
				FilterClusterID: "cluster-123",
			},
			expectedQuery: `CVE:"CVE-2021-44228"+Cluster ID:"cluster-123"`,
		},
	}

	for testName, testCase := range tests {
		t.Run(testName, func(t *testing.T) {
			result, output, err := tool.handle(context.Background(), &mcp.CallToolRequest{}, testCase.input)

			require.NoError(t, err)
			require.NotNil(t, output)
			assert.Nil(t, result)
			assert.Len(t, output.Clusters, 1)
			assert.Equal(t, testCase.expectedQuery, mockService.lastCallQuery)
		})
	}
}
